- Start Date: 2021-11-20
- RFC PR: https://github.com/reason-in-barcelona/jsoo-react/pull/67

# Summary

Right now, writing jsoo-react components and elements using OCaml syntax is pretty cumbersome, e.g.

https://github.com/reason-in-barcelona/jsoo-react/blob/45d3226c7ccf50c6ad7272c537949cc2c19015af/example/src/HelloWorldOCaml.ml#L1-L3

```ocaml
let make () = (div ~children:[React.string "Hello world from OCaml"] () [@JSX])
  [@@react.component]
```

This RFC tries to go through the different parts that need to be fixed in order to improve this experience.

# Basic example

The main idea is to enhance the ergonomics of jsoo-react for OCaml syntax. Here is a short example that shows component implementation and element creation:

```ocaml
[@@@react.dom]

module Greeting = struct
  let%component make ~name =
    button
      ~on_click:(fun _ -> ())
      ~children:[React.string ("Hello " ^ name ^ "!")]
      ()
end

let element = Greeting.make ~name:"John" ~children:[] ()
```

# Motivation

Having a better integration with OCaml syntax will reduce the friction to use React.js on OCaml codebases, which could lead to more use cases and projects where jsoo-react would make sense.

It also will make the library more appealing to those users that can't afford to add a dependency on Reason, or just prefer using OCaml syntax.

Finally, improving the ergonomics when using OCaml syntax will leverage all the stability, activity and functionality available in the OCaml ecosystem: tooling (ocamlformat, editor integrations), ppx, documentation, etc.

# Detailed design

The proposal is split between four different parts:
1. creation of DOM (lowercase) elements
2. creation of component (uppercase) elements
3. implementation of components
4. expose API in snakecase

### Creation of DOM elements

- **Current input**

  The current way to write elements relies on Reason ppx, which adds `[@JSX]` attributes to the ast. This means when writing elements from OCaml syntax, one has to include this attribute as well, e.g.:

  ```ocaml
  (div ~id:"foo" ~children:[] ())[@JSX ]
  ```

- **PPX output**

  The code generated by jsoo-react PPX for the input above is:

  ```ocaml
  React.Dom.createDOMElementVariadic "div"
    ~props:
      ( Js_of_ocaml.Js.Unsafe.obj
          [| ( "id"
             , Js_of_ocaml.Js.Unsafe.inject
                 (Js_of_ocaml.Js.string ("foo" : string)) ) |]
        : React.Dom.domProps )
    []
  ```

- **Goal**

  The goal is to get rid of adding manual attributes to each element, as creating DOM elements is something that happens very often in React apps.

- **Proposal**

  As we want to get rid of the `JSX` attribute, the proposal for creation of DOM elements is to add a floating attribute at the top of the files to indicate the PPX that we want it to enable the processing of DOM elements creation, e.g.

  ```ocaml
  [@@@react.dom]

  let my_element = div ~id:"foo" ~children:[] ()
  ```

  After processing the floating attribute, the ppx would check all functions with a name matching any of the known element tags (`"div"`, `"p"`, `"a"`,...) and it would process them automatically to apply the  conversion.

- **New input**

  After this change, writing DOM elements would look like this:

  ```ocaml
  div ~id:"foo" ~children:[] ()
  ```

### Creation of component elements

- **Current input**

  The current way to write component elements also relies on Reason ppx, which requires `[@JSX]`:

  ```ocaml
  Greeting.createElement ~name:"John" ~children:[] () [@JSX]
  ```

- **PPX output**

  ```ocaml
  React.createElement Greeting.make (Greeting.makeProps ~name:"John" ())
  ```

- **Goal**

  The goal, like in the previous case, is to avoid the need to add the `[@JSX]` attribute.

- **Proposal**

  Right now, the calls to `React.createElement` are inlined in the call point, but this is too cumbersome to be written manually.
  Instead, we can move these calls to the component implementation.

  So, for the following component implementation:

  ```ocaml
  [@react.component]
  let make = (~name) =>
    <button> {ReasonReact.string("Hello " ++ name ++ "!")} </button>;
  ```

  At present, the PPX produces the following output for the code above:

  ```ocaml
  let makeProps :
        name:'name
      -> ?key:string
      -> unit
      -> < name: 'name Js_of_ocaml.Js.readonly_prop > Js_of_ocaml.Js.t =
  fun ~name ?key _ ->
    let open Js_of_ocaml.Js.Unsafe in
    obj
      ( [| Option.map (fun raw -> ("key", inject (Js_of_ocaml.Js.string raw))) key
        ; Some ("name", inject name) |]
      |> Array.to_list
      |> List.filter_map (fun x -> x)
      |> Array.of_list )

  let make ~name =
    React.Dom.createDOMElementVariadic "button"
      ~props:(Js_of_ocaml.Js.Unsafe.obj [||])
      [ReasonReact.string ("Hello " ^ name ^ "!")]

  let make =
    let (Test
          (Props : < name: 'name Js_of_ocaml.Js.readonly_prop > Js_of_ocaml.Js.t)
          ) =
      make
        ~name:
          (fun (type res a0) (a0 : a0 Js_of_ocaml.Js.t)
              (_ : a0 -> < get: res ; .. > Js_of_ocaml.Js.gen_prop) ->
            (Js_of_ocaml.Js.Unsafe.get a0 "name" : res)
              (Props : < .. > Js_of_ocaml.Js.t)
              (fun x -> x#name) )
    in
    Test
  ```

  The PPX would need to add to the output an extra function at the end of the component implementation, that just calls `React.createElement` and pass `make` and `makeProps` defined before:

  ```ocaml
  let makeProps ... (* same as before *)

  let make ~name = ... (* same *)

  let make = ... (* same *)

  let make ~name () = React.createElement make (makeProps ~name ())
  ```

- **New input**

  After the change above, we can create component elements with just a function call from OCaml syntax:

  ```ocaml
  let my_element = Greeting.make ~name:"John" ()
  ```

### Implementation of components

- **Current input**

  Right now, components are defined with an attribute attached to the component value binding, e.g.:

  ```ocaml
  module Greeting = struct
    let make () = React.string "Hello world from OCaml" [@@react.component]
  end
  ```

- **Proposal**

  For OCaml syntax, it would be much friendlier to use infix syntax for component implementation, like it's done in [brisk-reconciler](https://github.com/briskml/brisk-reconciler/).

  The example above would look like:

  ```ocaml
  module Greeting = struct
    let%component make () = React.string "Hello world from OCaml"
  end
  ```

### Expose API in snake_case

All APIs should be aliased to make them available in snake case, e.g. functions like `React.use_state`, or props like `on_click`.

### Summary

Here is a component with some jsoo-react functionality to see how all the different parts would look like together:

  ```ocaml
  [@@@react.dom]

  open Bindings

  type action = Increment | Decrement

  let reducer state action =
    match action with Increment -> state + 1 | Decrement -> state - 1

  let s = React.string

  let space = " " |> s

  let%component make ?(name = "buddy") ?children =
    let count, set_count = React.use_state (fun () -> 0) in
    let state, dispatch = React.use_reducer reducer 0 in
    div
      ~id:"counter"
      ~children:
        [ p ~children:["Hello " ^ name ^ "!" |> s] ()
        ; button
            ~on_click:(fun _ ->
              Console.log "Click!" ;
              set_count (fun c -> c + 1) )
            ~children:["Count: " ^ string_of_int count |> s]
            ()
        ; space
        ; button
            ~on_click:(fun _ -> dispatch @@ Decrement)
            ~children:["Dec" |> s] ()
        ; space
        ; span ~children:[string_of_int state |> s] ()
        ; space
        ; button
            ~on_click:(fun _ -> dispatch @@ Increment)
            ~children:["Inc" |> s] ()
        ; space
        ; ( match children with
          | Some c ->
              div ~children:[c] ()
          | None ->
              React.null ) ]
      ()
  ```


# Drawbacks

- Performance: some of the points above like "1. Creating DOM elements" will involve more work from the PPX, as it has to check every `Pexp_apply` expression and then compare its `Pexp_ident` with all DOM elements `p`, `div`,... tag strings.
- Confusion and bad user experience: the proposal "1. Creating DOM elements" will lead to the PPX processing _every_ function with a name like DOM elements (`p`, `div`). This can lead to opaque compilation errors and confusion if the user redefines any of these functions for different purposes.
- Maintenance burden: the additions proposed will involve more maintenance work, and more use cases to support.
- Backwards compatibility: at some point we might decide to drop support for old ways to implement components using `[@react.component]`. This would mean that it'd not be as straight forward to migrate existing [ReasonReact](https://reasonml.github.io/reason-react) apps to jsoo-react.

# Unresolved questions

- Is there a better way to deal with DOM elements than using floating attributes?